import json
import os
import re
import subprocess
import threading
import time

import ai_1_
import split_orig_video
import au_vi_merge
import requests

import yt_dlp
import audio
from embed_srt import insert_subtitles


class FileDownloader:
    def download_file(self, url, local_filename, max_retries=8):
        retries = 0
        while retries < max_retries:
            try:
                # Send a GET request to the URL
                response = requests.get(url, stream=True)

                # Check if the request was successful
                if response.status_code == 200:
                    # Open the local file in binary write mode
                    with open(local_filename, 'wb') as file:
                        # Write the content of the response to the file
                        for chunk in response.iter_content(chunk_size=1024):
                            if chunk:
                                file.write(chunk)
                    p(f"File downloaded successfully and saved as {local_filename}")
                    break  # Exit the loop if download is successful
                else:
                    p(f"Failed to download file. HTTP Status Code: {response.status_code}")
                    return "error"
            except requests.exceptions.RequestException as e:
                retries += 1
                p(f"Retry {retries} failed: {e}")
                if retries == max_retries:
                    p("Max retries reached. Failed to download the file.")
                    return "error"


def p(text):
    d = __file__.split("/")[-1]
    print(f"[{d}] {text}")


class Youtube:
    def __init__(self, id=None, video=None, driver=None, standalone=None, link=None, path=None, machine=None):
        if standalone:
            proxy_url = 'http://127.0.0.1:8080'

            ydl_opts = {
                'proxy': proxy_url,
                'extract_flat': True,
                'socket_timeout': 5,
                'cookiefile': "netscape_cookies.txt",
                'outtmpl': f'{path}/clip.%(ext)s',
                'format': 'bestvideo[height<=1080][ext=mp4]+bestaudio[ext=m4a]/best[height<=1080][ext=mp4]/best',
                'skip_unavailable_fragments': False,  # Do not skip any fragments
                'fragment_retries': 10,  # Number of retries for a fragment
                'retries': 10
            }

            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                ydl.download(link)
                return

        self.video = video
        self.driver = driver
        self.id = id
        self.machine = machine
        self.get_cookies()
        self.list_mp3 = []
        self.downloader = FileDownloader

    def get_cookies(self):
        p("Getting cookies...")

        def gc():
            try:
                return self.driver.get_cookies()
            except:
                time.sleep(1)
                gc()

        cookies = gc()

        def convert_to_netscape(cookies):
            netscape_cookies = []
            for cookie in cookies:
                domain = cookie['domain']
                include_subdomains = 'TRUE' if domain.startswith('.') else 'FALSE'
                path = cookie['path']
                secure = 'TRUE' if cookie['secure'] else 'FALSE'
                expiry = cookie.get('expiry', 0)  # Use 0 if expiry is not present
                name = cookie['name']
                value = cookie['value']

                netscape_format = f"{domain}\t{include_subdomains}\t{path}\t{secure}\t{expiry}\t{name}\t{value}"
                netscape_cookies.append(netscape_format)

            return netscape_cookies

        # Convert cookies to Netscape format
        netscape_cookies = convert_to_netscape(cookies)

        with open('netscape_cookies.txt', 'w') as file:
            file.write("# Netscape HTTP Cookie File\n")
            file.write("# This file is generated by yt-dlp.  Do not edit.\n\n")
            for netscape_cookie in netscape_cookies:
                file.write(netscape_cookie + '\n')

        return "netscape_cookies.txt"

    def url(self):
        return f"https://www.youtube.com/watch?v={self.id}"

    def do_next(self):
        try:
            self.machine.cl.done(clip=self.machine.cl.to_download[-1])
            self.machine.clip.id = self.machine.cl.to_download[-1]
            self.id = self.machine.clip.id
        except:
            p("Can't do next clip, no clips left!!!!!")
            self.machine.do_next_error = 1



    def get_ip(self):
        result = subprocess.run(["route", "-n", "get", "default"], capture_output=True, text=True, check=True)

        # Extract the gateway line from the output
        gateway_line = [line for line in result.stdout.split('\n') if "gateway" in line]

        # Print the gateway IP address
        if gateway_line:
            gateway_ip = gateway_line[0].split(': ')[1]
            return gateway_ip
        else:
            raise ValueError("Gateway IP not found in the route output")

    def extract_text_from_subtitles(self, subtitle_file):
        with open(subtitle_file, 'r') as file:
            content = file.read()

        text_pattern = re.compile(r'\d+\n\d{2}:\d{2}:\d{2},\d{3} --> \d{2}:\d{2}:\d{2},\d{3}\n(.*?)\n', re.DOTALL)

        # Find all matches
        matches = text_pattern.findall(content)

        # Join the extracted text into a single string
        extracted_text = '\n'.join(matches)

        return extracted_text




    def translate(self, custom=None):
        p(f"Translation has been called with text {custom}")
        d = 0


        if custom is not None:
            p("Doing custom translation")
            while d != 4:
                d += 1
                print(d)
                try:
                    text = custom
                    cust_sys = "Переведи этот загловок на русский и в ответе укажи только перевод и дополнительно придуманных 5 хэштегов"
                    response = ai_1_.response(text=text, cust_sys=cust_sys)
                    return response


                except:
                    p("Error during translation, waiting 3 seconds and retrying..")
                    time.sleep(3)
                    continue

        while d != 4:
            d += 1
            p("Doing translation from an .srt")
            try:
                text = self.extract_text_from_subtitles(f'./videos/{self.video.hashed}.srt')
                response = ai_1_.response(text)
                return response

            except Exception as e:
                p(f"Error during translation, waiting 3 seconds and retrying..\n{e}")
                time.sleep(3)
                continue

    def download(self):
        self.driver.get("https://www.youtube.com")
        video = self.video
        self.video.hashed = int(time.time())

        def process():

            ################################
            ydl_opts = {
                'quiet': not self.machine.settings.verbose,
                'extract_flat': True,
                'cookiefile': self.get_cookies(),
                'outtmpl': f'{video.path}/{video.hashed}.%(ext)s',
                'format': 'bestvideo[height<=1080][ext=mp4]+bestaudio[ext=m4a]/best[height<=1080][ext=mp4]/best',
                'skip_unavailable_fragments': False,
                'fragment_retries': 5,  # Reduced retries
                'fragment_threads': 2,
                'retries': 5  # Reduced retries
            }

            while True:
                if self.machine.do_next_error == 1: return

                try:
                    with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                        info = ydl.extract_info(self.url(), download=False)

                        duration = info['duration']
                        if duration < 10:
                            p("Video too short, skipping")
                            self.do_next()
                            process()
                            break

                        video.title = info['title']
                        self.video.title = info['title']
                        video.description = info['description']
                        p(video.title)

                        def trans():
                            if self.machine.translate is False:
                                p("Translating the title")
                                self.video.title = self.translate(custom=video.title)
                                p(video.title)

                        d = threading.Thread(target=trans)
                        d.start()

                        ydl.download([self.url()])
                        d.join()
                        p("Video downloaded")
                        break

                except yt_dlp.utils.DownloadError as e:

                    p(f'DownloadError: {e}')
                    if "Sign in to confirm you’re not a bot" in str(e):
                        p("Trying to get new cookies!")
                        self.get_cookies()
                        process()

                    if "Video unavailable" in str(e):
                        p("SKIPPING CLIP")
                        self.do_next()
                        process()

                    if "This video contains content from SME" in str(e):
                        p("SKIPPING CLIP")
                        self.do_next()
                        process()


                except yt_dlp.utils.ExtractorError as e:
                    p(f'ExtractorError: {e}')

                except Exception as e:
                    p(f'An error occurred: {e}')

        down_video = threading.Thread(target=process)
        down_video.start()



        if self.machine.translate is False:
            down_video.join()
            return

        result = audio.act(self.id, "./videos", self.video.hashed)
        new_title = self.translate()

        if result == 1:
            down_video.join()
            p("Couldnt get any audio or subs for this video")
            self.do_next()
            down_video.join()
            return process()



        down_video.join()

        if self.machine.do_next_error == 1: return

        split_orig_video.do_it(self.video.hashed, self.driver, self.downloader)

        # remove_emojis = lambda text: re.sub(r'[^\x00-\x7F]+', '', text)
        # self.video.title = remove_emojis(self.video.title)




            # script = script.read()
            # ai_ = AI_server(self.driver)
            # new_title = ai_.send(request=script)
            # print(new_title)

        if "error!!!" in new_title:
            try:
                self.machine.cl.done(clip=self.machine.cl.to_download[-1])
                self.machine.clip.id = self.machine.cl.to_download[-1]
            except:
                pass

            try:
                os.remove(f'./videos/{self.video.hashed}.mp4')
                os.remove(f'./videos/{self.video.hashed}_2.mp4')
                os.remove(f'./videos/{self.video.hashed}.mp3')
                os.remove(f'./videos/{self.video.hashed}.srt')
            except:
                pass
            p("Prohibited content detected!!!")
            self.downloader()
            return

        self.video.title = new_title[:-4].replace('"', '').replace("\n", " ")

        video_file = f'./videos/{self.video.hashed}.mp4'
        audio_file = f'./videos/{self.video.hashed}.mp3'
        output_file = f'./videos/{self.video.hashed}_2.mp4'
        subtitles_path = f'./videos/{self.video.hashed}.srt'

        au_vi_merge.layer_audio(video_file, audio_file, output_file)
        os.remove(f'./videos/{self.video.hashed}.mp4')
        insert_subtitles(output_file, subtitles_path, video_file)

        os.remove(f'./videos/{self.video.hashed}_2.mp4')
        os.remove(f'./videos/{self.video.hashed}.mp3')
        os.remove(f'./videos/{self.video.hashed}.srt')
